%   File: GMEB_IllustrativeExample.m
%   Copyright (c) <2020> <University of Mons>
%   COLORAMAP Group, Univ. of Mons, Belgium
%   https://sites.google.com/site/nicolasgillis/projects/overview
%
%   Permission is hereby granted, free of charge, to any person
%   obtaining a copy of this software and associated documentation
%   files (the "Software"), to deal in the Software without restriction,
%   including without limitation the rights to use, copy, modify and
%   merge the Software, subject to the following conditions:
%
%   1.) The Software is used for non-commercial research and
%       education purposes.
%
%   2.) The above copyright notice and this permission notice shall be
%       included in all copies or substantial portions of the Software.
%
%   3.) Publication, Distribution, Sublicensing, and/or Selling of
%       copies or parts of the Software requires special agreements
%       with the University of Mons and is in general not permitted.
%
%   4.) Modifications or contributions to the software must be
%       published under this license. The University of Mons
%       is granted the non-exclusive right to publish modifications
%       or contributions in future versions of the Software free of charge.
% 
%   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
%   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
%   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
%   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
%   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
%   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
%   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
%   OTHER DEALINGS IN THE SOFTWARE.
%
%   Persons using the Software are encouraged to notify the 
%   COLORAMAP Group, Univ. of Mons, Belgium about bugs. Please reference 
%   the Software in your publications if it was used for them.
%
% ------------------------------------------------------------------------
% SYNTAX:
% GMEB_IllustrativeExample( scenario );
%
% ------------------------------------------------------------------------
%
% OVERVIEW:
% This script visualizes the various types of data generated by 
% GMEB_DataGen.m and computes the center of the minimum enclosing ball and 
% the Karcher mean of the data.  The results are then projected into
% 2-dimensional Euclidean space via a multidimensional scaling.
%
% Displays plots corresponding to Fig. 3 and Fig. 4 in the paper.
%
% ------------------------------------------------------------------------
% INPUTS:
% scenario  String that specificies the figure to reproduce.
%           'Fig. 3a'/'Fig. 3b'/'Fig. 4a'/'Fig. 4b'
%
% ------------------------------------------------------------------------
% OUTPUTS: 
% n/a
% ------------------------------------------------------------------------
% DEPENDENCIES:
% [a] GMEB_ScenarioSpecification.m
%       Not included within.
%       Sets scenario parameters.
%       Written by T. Marrinan; see file for documentation.
%
% [b] GMEB_DataGen.m
%       Not included.
%       Written by T. Marrinan, see file for documentation.
%
% [c] GMEB_DualSubgrad.m
%       Not included. 
%       Written by Tim Marrinan, see file for documentation.
%
% [d] KarcherMean.m       
%       Not included.
%       Written by Tim Marrinan, see file for documentation.
%
% [e] GrDist.m       
%       Not included.
%       Written by Tim Marrinan, see file for documentation.
%
% [f] diffusionKernel.m       
%       Not included.
%       Written by Tim Marrinan, see file for documentation.
%
% ------------------------------------------------------------------------
% REFERENCES:
% If this code is useful for you, please cite the paper:
% [1] 	Marrinan, Tim, P.-A. Absil, and Nicolas Gillis
%	"On a minimum enclosing ball of a collection of linear subspaces."
%     	arXiv preprint arXiv:2003.12455 (2020).
%
% ------------------------------------------------------------------------
% CREATED:      03/07/2019 by Tim Marrinan
%
% LAST EDITED:  12/04/2020 by Tim Marrinan
%
% NOTES: 
% 
% Keep in mind that the embedding into 2D depends on the distribution of
% the original data samples, so it doesn't always look exactly like a
% circle in the lower dimensions. These data are actually lines in 3D and a
% good sample with the nested balls would look kind of like the death star.
%
% ------------------------------------------------------------------------
% clear all; clc;
function GMEB_IllustrativeExample( scenario )

%% Experimental setup:
%scenario    = 'Fig. 3a';                            % Choose scenario
%scenario    = 'Fig. 3b';                            % Choose scenario
%scenario    = 'Fig. 4a';                            % Choose scenario
%scenario    = 'Fig. 4b';                            % Choose scenario
[param, dual_options, ~, ~] =  ...
    GMEB_ScenarioSpecification( scenario );         % Set parameters
method      = 'multidimensional scaling';           % 'multidimensional scaling'/'diffusion map'/'pca'
k           = param.common_dims_bb;                 % Optimal dimension
d_type      = param.d_type;                         % Distance measure
printout    = 'verbose';                            % 'verbose'/'none'
threeD      = false;                                % true/false;



%% Main script
switch lower(printout)
    case 'verbose'
        clc
        fprintf('\t--------------------------------------------------------\n');
        fprintf('\tIllustrative Example:\n');
        fprintf('\tScenario:\t\t\t%s\n',scenario);
        fprintf('\tDim. reduction:\t\t%s\n',method);
        fprintf('\t--------------------------------------------------------\n');
    otherwise
end

% Need to clear the subspace dimensions from the parameter
% vector each time otherwise they will not be randomly
% resampled
if isfield(param,'dims_bb')
    param = rmfield(param,'dims_bb');
end
if isfield(param,'dims_sb')
    param = rmfield(param,'dims_sb');
end
if isfield(param,'dims_bb_int')
    param = rmfield(param,'dims_bb_int');
end
if isfield(param,'dims_sb_int')
    param = rmfield(param,'dims_sb_int');
end
% Generate data
[ data, param ] = GMEB_DataGen( param );


switch lower(scenario)
    case 'fig. 3a'
        pts = data.clean_samples_all;
        nBB = param.num_samples_bb;
        nSB = param.num_samples_sb;
    case 'fig. 3b'
        pts = data.clean_samples_both;
        nBB = ceil(param.num_samples_bb*(param.int_pts_ratio+1));
        nSB = ceil(param.num_samples_sb*(param.int_pts_ratio+1));
    case 'fig. 4a'
        pts = data.clean_samples_all;
        nBB = param.num_samples_bb;
        nSB = param.num_samples_sb;
    case 'fig. 4b'
        pts = data.clean_samples_both;
        nBB = ceil(param.num_samples_bb*(param.int_pts_ratio+1));
        nSB = ceil(param.num_samples_sb*(param.int_pts_ratio+1));
    otherwise
        
end
n_sets = size(pts,1);

%% Compute averages    
% Center of the minimum enclosing ball
[~, final, ~] = GMEB_DualSubgrad(pts, k, dual_options);
GMEB = final.u;

% Center of mass
[karcher, ~, ~, ~] = KarcherMean(pts, pts{1}, 10^-6, 1000, 0);


%% Embed data 
pts{n_sets+1} = karcher;
pts{n_sets+2} = GMEB;
pts{n_sets+3} = data.center;               
distMat = zeros(size(pts,1),size(pts,1));
for i = 1 : size(pts,1)
    for j = i + 1 : size(pts,1)
        distMat(i,j) = GrDist(pts{i},pts{j},k,d_type);
        distMat(j,i) = distMat(i,j);
    end
end
switch lower(method)
    case 'multidimensional scaling'
        clear coords evals L_sharp
        [coords,~] = cmdscale(distMat,3);
        cc_karcher = coords(n_sets+1,:);
        cc_GMEB = coords(n_sets+2,:);
        cc_true = coords(n_sets+3,:);
    case ' diffusion map'
        clear coords evals L_sharp
        [coords] = diffusionKernel(distMat,20,1,3);
        cc_karcher = coords(n_sets+1,:);
        cc_GMEB = coords(n_sets+2,:);
        cc_true = coords(n_sets+3,:);
    case 'pca'
        % Need to make everything point the same way
        [~,ind] = max(abs(pts{n_sets+3}));
        for i = 1 : n_sets+3
            if pts{i}(ind) < 0
                j = j + 1;
                pts{i} = -1*pts{i};
            end
        end
        coeff = pca([pts{:}]');
        coords = [pts{:}]'*coeff;
        cc_karcher = coords(n_sets+1,:);
        cc_GMEB = coords(n_sets+2,:);
        cc_true = coords(n_sets+3,:);
    otherwise
        error('Unknown embedding method');   
end

    
%%    
true_center_color = [17,119,51]/255;
karcher_color = [68 119 170]/255;
gmeb_color = [221 204 119]/255;

fig_width = 12;
fig_height = 12;
figure('units','centimeters','Position',[4,4,fig_width,fig_height]);


if threeD
    switch lower(printout)
        case 'verbose'
            fprintf('\n\tNote:\tAntipodal points on the sphere represent\n');
            fprintf('\t\t\tthe same point on Gr(1,3), so only one hemisphere\n');
            fprintf('\t\t\twill appear to contain points...\n');
        otherwise
    end
    exes = scatter3(coords(1:nBB,1),coords(1:nBB,2),coords(1:nBB,3),...
        'x','MarkerEdgeColor','k','MarkerFaceColor',[1 1 1],...
        'DisplayName','$\*X_i \in \mathcal{B}_{0.5}(\mathbf{Z}_1)$');
    hold on
    ohs = scatter3(coords(nBB+1:nBB+nSB,1),coords(nBB+1:nBB+nSB,2),...
        coords(nBB+1:nBB+nSB,3),'o','MarkerEdgeColor','k',...
        'MarkerFaceColor',[1 1 1],'DisplayName',...
        '$\*X_i \in \mathcal{B}_{0.05}(\mathbf{Z}_2)$');
    km = scatter3(cc_karcher(1)',cc_karcher(2)',cc_karcher(3)',100,'o',...
        'MarkerEdgeColor','k','MarkerFaceColor',karcher_color,...
        'DisplayName','Karcher mean');
    tm = scatter3(cc_true(1)',cc_true(2)',cc_true(3)',200,'s',...
        'MarkerEdgeColor','k','MarkerFaceColor',true_center_color,...
        'DisplayName','True center');
    gm = scatter3(cc_GMEB(1)',cc_GMEB(2)',cc_GMEB(3)',100,'d',...
        'MarkerEdgeColor','k','MarkerFaceColor',gmeb_color,...
        'DisplayName','Estimated center');
    title(scenario)
    xlim([min(coords(:,1)),max(coords(:,1))])
    ylim([min(coords(:,2)),max(coords(:,2))])
    zlim([min(coords(:,3)),max(coords(:,3))])
    l = legend('Location','best');
    set(l, 'Interpreter', 'latex')
    set(gca,'visible','off')
    hold off
    %alpha(km,.75)
    %alpha(gm,.75)
else
    exes = scatter(coords(1:nBB,1),coords(1:nBB,2),'x',...
        'MarkerEdgeColor','k','MarkerFaceColor',[1 1 1],...
        'DisplayName','$\*X_i \in \mathcal{B}_{0.5}(\mathbf{Z}_1)$');
    hold on
    ohs = scatter(coords(nBB+1:nBB+nSB,1),coords(nBB+1:nBB+nSB,2),'o',...
        'MarkerEdgeColor','k','MarkerFaceColor',[1 1 1],'DisplayName',...
        '$\*X_i \in \mathcal{B}_{0.05}(\mathbf{Z}_2)$');
    km = scatter(cc_karcher(1)',cc_karcher(2)',100,'o',...
        'MarkerEdgeColor','k','MarkerFaceColor',karcher_color,...
        'DisplayName','Karcher mean');
    tm = scatter(cc_true(1)',cc_true(2)',200,'s',...   
        'MarkerEdgeColor','k','MarkerFaceColor',true_center_color,...
        'DisplayName','True center');
    gm = scatter(cc_GMEB(1)',cc_GMEB(2)',100,'d',...
        'MarkerEdgeColor','k','MarkerFaceColor',...
        gmeb_color,'DisplayName','Estimated center');
    title(scenario)
    xlim([min(coords(:,1)),max(coords(:,1))])
    ylim([min(coords(:,2)),max(coords(:,2))])
    l = legend('Location','best');
    set(l, 'Interpreter', 'latex')
    set(gca,'visible','off')
    hold off
end

